\secrel{Учебник}\secdown

\secly{Запуск}

Ядро системы реализовано в виде единстеного .exe файла\note{консольная
программа}. При простом запуске открывается интерактивная сессия, для загрузки
скрипта из файла используйте команду

\begin{verbatim}
bI.exe < script.bI > script.blog
\end{verbatim}

В Linux исполняемым может быть сделан \emph{любой} файл, добавьте к своим
скриптам первой строкой полный путь к bI.elf:
\begin{verbatim}
#!/home/user/bI_script/bI.elf
\end{verbatim}
и выполните команду
\begin{verbatim}
chmod +x script.bI
\end{verbatim}

\secrel{Базовый AST-тип}\label{ast}

Язык bI реализован на базе операций с элементами данных,
представленных в виде \termdef{символьного типа}\ AST:\\

\begin{tabular}{l l l}
class AST:sym & \\
&string:tag & тип данных (тэг класса) \\
&string:value & значение \\
&sym:nest$[]$ & список вложенных элементов данных \\
&sym:par$\{\}$ & словарь параметров \\
&string:dump() & вывод элемента данных в текстовом виде в виде дерева \\
&string:tagval() & строковое представление основной части <тэг:значение$[$,параметры$]$> \\
&sym:eval() & вычисление (evaluate) элемента данных \\
\end{tabular}

\bigskip
Базовый объект задается \term{парой}\ref{pair} \verb|тэг:значение|.

\bigskip
Каждый AST-объект может иметь вложенные элементы в списке \verb|next[]|.

\bigskip
Также каждому элементу можно присваивать произвольное количество параметров,
хранящися в словаре\note{тип \py}\ \verb|par{}|.

\bigskip
Относительно сложный AST-тип (по сравнению с списковыми типами \lisp а)
был выбран в качестве базового, так как изначально язык \bi\ создавался как
\emph{высокоуровневый экспериментальный язык-шаблонизатор}
для разработки средств трансляции,
компиляторов, синтаксического анализа текстовых форматов данных, 
автогенерации кода на базе высокоуровневых определений, и символьных вычислений.

\secrel{Скалярные типы (атомы, литералы)}\secdown

\secrel{Комментарии}

Строчные комментарии начинаются с символа \#:

\begin{framed}
Создайте файл script.bI, запишите в него 
\begin{verbatim}
#!/home/user/bI_script/bI.elf
# syntax sample with numbers, symbols, [] lists and stack ops
# John McCarthy A Micro-Manual for Lisp - not the whole Truth.
\end{verbatim}
и выполните через \bi-интерпретатор:
\begin{verbatim}
bI.exe < script.bI
\end{verbatim}
\end{framed}

\secrel{docstring: строка документации}

Для документирования программ из языка \py\ была позаимствована идея docstring:
каждый объект может иметь параметр \verb|par[doc]|, в котором хранится объект
документации: строка или более сложный тип.

Для задания docstring в тексте программ используются "двойные кавычки": 
созданная докстрока будет присвоена \emph{ближайшему слева} программному 
объекту\note{правая ассоциативность}.

\secrel{Числа, строки и символы}

\begin{itemize}[nosep]
\item числа
\begin{itemize}[nosep]
\item целые:\\
-01 -0 00 +0 +02222 $\rightarrow$ <int:-1> <int:0> <int:0> <int:0> <int:2222>
\item с плавающей точкой в простой и экспоненциальной форме:\\
+02.30 -04E+05 $\rightarrow$ <num:2.3> <num:-400000>
\item шестнадцатеричные и бинарные машинные числа:\\
0x12AF 0b1101 $\rightarrow$ <hex:0x12AF> <bin:0b1101>
\end{itemize}
\item строки\\
'строка' $\rightarrow$ <str:'строка'>
\item символы: в простейшем виде просто задает уникальное имя\\
symbol $\rightarrow$ <sym:symbol>\\
\end{itemize}

\secup

\secrel{Композитные типы}\secdown

\secrel{$[$Список$]$}

Список\ --- \termdef{композитная}\ структура данных, позволяющая рассматривать
произвольный набор данных как один объект. Списки могут быть вложенными.

\bigskip\label{nestdata}
Добавьте в script.bI или выполните в интерактивной сессии\note{запустив bI.exe
без параметров}\ код:
\begin{verbatim}
# пример синтаксиса с числами, символами, и вложенными списками: 
[ 
    [-01 -0 00 +0 +02222] "целые"
    [ 0x12AF 0b1101 ] "машинные числа"
    [ +02.30 -04E+05 ] "числа с плавающей точкой"
] 
'string' "пример строки"
symbol "пример символа"
? # вывести дамп стека
~ # dropall: полнолстью очистить стек данных
? # еще раз вывести стек
\end{verbatim}

\secrel{Па:ра}\label{pair}

Через \termdef{пары}\ вида \verb|A:B|\ реализуются деревья, списки в Lisp-стиле, и 
описание ООП-структур.

\secrel{<Вектор>}

<Вектор> аналогичен списку, но имеет \emph{фиксированную размерность}.

\bigskip
Фиксированная размерность позволяет генерировать оптимизированный код,
и значительно упрощает управление памятью, что критически важно для 
реализации численных методов.

\secrel{$[$Сло:варь$]$}

\secup

\secrel{Заимствования из языка \F}\secdown

В языке \F\ программа представляет собой последовательность \termdef{слов}-команд,
разделенных пробелами\note{сам пробел, табуляция и концы строк DOS/UNIX}.
Когда интерпретатор \F\ встречает \term{слово}, он ищет
его в \term{словаре}, и если оно найдено\ --- исполняет. 

Если слово не найдно, 
\F\ пытается его прочитать как целое число, при успехе кладет на стек, иначе 
выводит ошибку. Плавающей точки нет вообще.

Строки обрабатываются особо: слово \verb|."|\ \note{с обязательным за ним 
пробелом}\ читает входной поток, пока не встретит символ \verb|"|, и кладет на 
стек адрес строки.

\bigskip
Язык \bi\ расширяет синтаксис \F а\note{рассматривая
все данные как обобщенный AST-тип\ref{ast}}\ инфиксными выражениями, 
встроенными типами
данных, высокоуровневой библиотекой символьных вычислений и ООП. 

\secrel{Стек данных}

Каждое выражение языка \bi\ после вычисления кладется на стек данных.

\begin{framed}
Стек\ --- структура данных, поддерживающая операции:

\bigskip
\begin{tabular}{l l l}
push(объект) & ( A B C -- A B C obj ) & поместить объект на вершину стека \\
pop()$\rightarrow$объект & ( A B C obj -- A B C ) & взять объект с вершины \\
стековые функции\ref{Ffn} && выполняют вычисления на стеке \\
\end{tabular}  
\end{framed}

Для записи состояния стека используется строчная \F-нотация: 
элементы записываются слева 
направо, вершина\ --- самый правый элемент. Для встроенных 
\F-функций\ref{Ffn}\ используется нотация вида\\ \verb|A B C -- A C B|, 
в левой части состояние стека
до выполнения функции, справа\ --- после того, как функция выполнила
\termdef{вычисления на стеке данных}. 

\bigskip
\begin{tabular}{l l}
? & вывести стек (вершина внизу) \\
\textasciitilde & очистить стек \\
\end{tabular}
\bigskip

Команда ?\ выводит стек в полной текстовой форме в виде дерева, для составных
объектов включаются все вложенные элементы. Стек выводится сверху вниз, вершина
стека\ --- самый нижний элемент.

\bigskip
При вполнении примера \ref{nestdata}\ будет выведено (список списков чисел,
строка и символ):
\begin{verbatim}
========= stack ==========
<[:]>
    <[:],doc:<str:'integers'>>
        <int:-1>
        <int:0>
        <int:0>
        <int:0>
        <int:2222>
    <[:],doc:<str:'machine numbers'>>
        <hex:0x12AF>
        <bin:0b1101>
    <[:],doc:<str:'float numerics'>>
        <num:2.3>
        <num:-400000>
<str:'string'>
<sym:symbol,doc:<str:'generic symbol'>>
==========================

========= stack ==========
==========================
\end{verbatim}

0ой элемент = вершина стека\ --- символ;

-1ый элемент строка;

-2ой элемент = дно стека\ --- вложенный список чисел разных типов.

\secrel{\F-функции на стеке данных}\label{Ffn}

\begin{framed}
Стек данных и \F-функции были введены в язык \bi\ как упрощение, позволяющее
реализовать лямбды и определение функций.

Явное использование стека данных позволяет определять лямбды как простой список
имен ранее определенных и встроенных функций, выполняющих операции на стеке.

Это позволяет обойтись без подстановки параметров в традиционном стиле 
реализации лябда-функций.  
\end{framed}

\F-функции выполняют вычисления на стеке данных, явно манипулируя элементами
на вершине:

\bigskip
\begin{tabular}{l l l}
push(объект) & ( A B C -- A B C obj ) & поместить объект на вершину стека \\
pop()$\rightarrow$объект & ( A B C obj -- A B C ) & взять объект с вершины \\
\hline
? & аналог .S & вывести полный дамп стека \\
\textasciitilde & аналог DROPALL & очистить стек \\
print & аналог . ( A B -- A ) & вычислить и вывести символьное представление \\ 
\hline
dup & ( A B \textcolor{Blue}{C} -- A B \textcolor{Blue}{C C} ) & продублировать верхний элемент \\
drop & ( A B \textcolor{Blue}{C} -- A B ) & убрать один элемент с вершины \\
swap & ( A \textcolor{Blue}{B C} -- A \textcolor{Blue}{C B} ) & обмен 2х объектов на стеке \\
over & ( A \textcolor{Blue}{B} C -- A B C \textcolor{Blue}{B} ) & вытащить копию -1-ого элемента на вершину \\
\end{tabular}

\secup

\secrel{Функциональные типы}\secdown

\secrel{Лямбды}

Лямбда\ --- анонимная функция. В текущей версии \bi\ классические
лямбды с параметрами не поддерживаются, доступно только определение в виде
\F-функций\ref{Ffn}, выполняющих вычисления на стеке данных. Эта реализация
намного проще в реализации, но имеет значительный недостаток\ --- 
\emph{вычисления выполняются декструктивно, а не функционально}.

\secrel{Определение именованных функций}

Для задания именованной функции достаточно присвоить лямбду символу:

\bigskip\noindent
\#\ $ x \rightarrow\ sin(x) \rightarrow\ sin(x)\ sin(x) \rightarrow\ sin^2(x) $
\begin{verbatim}
sin2x = { sin apply dup apply mul apply } 
\end{verbatim}

\secrel{Явная аппликация}

Поскольку в \bi\ функции являются таким же типом данных, как и остальные, 
для применения (\termdef{аппликации}) функции, т.е. вычисления функции, 
применяется встроенная функция \verb|apply|\ и оператор \verb|@|.

\secrel{Декомпозиция: программы как данные}

Важнейшее значение в языке \bi\ имеет заимствованный из \lisp а принцип
"программа = данные"\ и поддержка ядром языка функций высших порядков:

\begin{framed}
\termdef{Функция высшего порядка}\ --- функция, способная создавать, принимать
в качестве параметров, и \emph{модифицировать}\ другие функции.
\end{framed}

Собственно, язык \bi\ и был создан из необходимости наличия в языке ФВП,
полного набора возможностей динамического языка, 
и с удобным (и более вменяемым по сравнению с \lisp ом) синтаксисом.

\secup

\secrel{ООП}

\secup
