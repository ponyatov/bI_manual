\secrel{Учебник}\secdown

\secly{Запуск}

Ядро системы реализовано в виде единстеного .exe файла\note{консольная
программа}. При простом запуске открывается интерактивная сессия, для загрузки
скрипта из файла используйте команду

\begin{verbatim}
bI.exe < script.bI > script.blog
\end{verbatim}

В Linux исполняемым может быть сделан \emph{любой} файл, добавьте к своим
скриптам первой строкой полный путь к bI.elf:
\begin{verbatim}
#!/home/user/bI_script/bI.elf
\end{verbatim}
и выполните команду
\begin{verbatim}
chmod +x script.bI
\end{verbatim}

\secly{Комментарии}

Строчные комментарии начинаются с символа \#:

\begin{framed}
Создайте файл script.bI, запишите в него 
\begin{verbatim}
#!/home/user/bI_script/bI.elf
# syntax sample with numbers, symbols, [] lists and stack ops
# John McCarthy A Micro-Manual for Lisp - not the whole Truth.
\end{verbatim}
и выполните через \bi-интерпретатор:
\begin{verbatim}
bI.exe < script.bI
\end{verbatim}
\end{framed}

\secly{AST-тип}\label{ast}

Язык bI реализован на базе операций с элементами данных,
представленных в виде \termdef{символьного типа}\ AST:\\

\begin{tabular}{l l l}
class AST:sym & \\
&string:tag & тип данных (тэг класса) \\
&string:value & значение \\
&sym:nest$[]$ & список вложенных элементов данных \\
&string:dump() & вывод элемента данных в текстовом виде в виде дерева \\
&string:tagval() & строковое представление только основной части <тэг:значение> \\
&sym:eval() & вычисление (evaluate) элемента данных \\
\end{tabular}

\secly{Скалярные типы (атомы, литералы)}

\begin{itemize}[nosep]
\item числа
\begin{itemize}[nosep]
\item целые:\\
-01 -0 00 +0 +02222 $\rightarrow$ <int:-1> <int:0> <int:0> <int:0> <int:2222>
\item с плавающей точкой в простой и экспоненциальной форме:\\
+02.30 -04E+05 $\rightarrow$ <num:2.3> <num:-400000>
\item шестнадцатеричные и бинарные машинные константы:\\
0x12AF 0b1101 $\rightarrow$ <hex:0x12AF> <bin:0b1101>
\end{itemize}
\item 'строки'
\item символы: в простейшем виде просто задает уникальное имя\\
symbol $\rightarrow$ <sym:symbol>\\
\end{itemize}

\secrel{Композитные типы}\secdown

\secrel{Список}

Список\ --- \termdef{композитная}\ структура данных, позволяющая рассматривать
произвольный набор данных как один объект. Списки могут быть вложенными.

\bigskip\label{nestdata}
Добавьте в script.bI или выполните в интерактивной сессии\note{запустив bI.exe
без параметров}\ код:
\begin{verbatim}
# пример синтаксиса с числами, символами, и вложенными списками: 
[ [-01 -0 00 +0 +02222] [ 0x12AF 0b1101 ] [ +02.30 -04E+05 ] ]
'string'
symbol 
? # вывести дамп стека
~ # dropall: полнолстью очистить стек данных
? # еще раз вывести стек
\end{verbatim}

\secrel{Пара}

Через пары вида \verb|A:B|\ реализуются деревья, списки в Lisp-стиле, и 
описание ООП-структур.

\secup

\secrel{Заимствования из языка \F}\secdown

В языке \F\ программа представляет собой последовательность \termdef{слов}-команд,
разделенных пробелами\note{сам пробел, табуляция и концы строк DOS/UNIX}.
Когда интерпретатор \F\ встречает \term{слово}, он ищет
его в \term{словаре}, и если оно найдено\ --- исполняет. 

Если слово не найдно, 
\F\ пытается его прочитать как целое число, при успехе кладет на стек, иначе 
выводит ошибку. Плавающей точки нет вообще.

Строки обрабатываются особо: слово \verb|."|\ \note{с обязательным за ним 
пробелом}\ читает входной поток, пока не встретит символ \verb|"|, и кладет на 
стек адрес строки.

\bigskip
Язык \bi\ расширяет синтаксис \F а инфиксными выражениями, встроенными типами
данных, высокоуровневой библиотекой символьных вычислений и ООП\note{рассматривая
все данные как обобщенный AST-тип\ref{ast}}. 

\secrel{Стек данных}

Каждое выражение языка \bi\ после вычисления кладется на стек данных.

\begin{framed}
Стек\ --- структура данных, поддерживающая операции:

\bigskip
\begin{tabular}{l l l}
push(объект) & ( A B C -- A B C obj ) & поместить объект на вершину стека \\
pop()$\rightarrow$объект & ( A B C obj -- A B C ) & взять объект с вершины \\
стековые функции\ref{Ffn} && выполняют вычисления на стеке \\
\end{tabular}  
\end{framed}

Для записи состояния стека используется строчная \F-нотация: 
элементы записываются слева 
направо, вершина\ --- самый правый элемент. Для встроенных 
\F-функций\ref{Ffn}\ используется нотация вида\\ \verb|A B C -- A C B|, 
в левой части состояние стека
до выполнения функции, справа\ --- после того, как функция выполнила
\termdef{вычисления на стеке данных}. 

\bigskip
\begin{tabular}{l l}
? & вывести стек (вершина внизу) \\
\textasciitilde & очистить стек \\
\end{tabular}
\bigskip

Команда ?\ выводит стек в полной текстовой форме в виде дерева, для составных
объектов включаются все вложенные элементы. Стек выводится сверху вниз, вершина
стека\ --- самый нижний элемент.

\bigskip
При вполнении примера \ref{nestdata}\ будет выведено (список списков чисел,
строка и символ):
\begin{verbatim}
========= stack ==========
<[:]>
    <[:]>
        <int:-1>
        <int:0>
        <int:0>
        <int:0>
        <int:2222>
    <[:]>
        <hex:0x12AF>
        <bin:0b1101>
    <[:]>
        <num:2.3>
        <num:-400000>
<str:'string'>
<sym:symbol>
==========================

========= stack ==========
========================== 
\end{verbatim}

\secrel{\F-функции на стеке данных}\label{Ffn}

\begin{framed}
Стек данных и \F-функции были введены в язык \bi\ как упрощение, позволяющее
реализовать лямбды и определение функций.

Явное использование стека данных позволяет определять лямбды как простой список
имен ранее определенных и встроенных функций, выполняющих операции на стеке.

Это позволяет обойтись без подстановки параметров в традиционном стиле 
реализации лябда-функций.  
\end{framed}

\F-функции выполняют вычисления на стеке данных, явно манипулируя элементами
на вершине:

\bigskip
\begin{tabular}{l l l}
push(объект) & ( A B C -- A B C obj ) & поместить объект на вершину стека \\
pop()$\rightarrow$объект & ( A B C obj -- A B C ) & взять объект с вершины \\
\hline
? & аналог .S & вывести полный дамп стека \\
\textasciitilde & аналог DROPALL & очистить стек \\
print & аналог . ( A B -- A ) & вычислить и вывести символьное представление \\ 
\hline
dup & ( A B \textcolor{Blue}{C} -- A B \textcolor{Blue}{C C} ) & продублировать верхний элемент \\
drop & ( A B \textcolor{Blue}{C} -- A B ) & убрать один элемент с вершины \\
swap & ( A \textcolor{Blue}{B C} -- A \textcolor{Blue}{C B} ) & обмен 2х объектов на стеке \\
over & ( A \textcolor{Blue}{B} C -- A B C \textcolor{Blue}{B} ) & вытащить копию -1-ого элемента на вершину \\
\end{tabular}

\secup

\secrel{ООП}

\secup
